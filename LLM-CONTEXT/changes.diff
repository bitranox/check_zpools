diff --git a/src/check_zpools/alerting.py b/src/check_zpools/alerting.py
index b29a256..10bacd0 100755
--- a/src/check_zpools/alerting.py
+++ b/src/check_zpools/alerting.py
@@ -23,13 +23,17 @@ from __future__ import annotations
 
 import logging
 import socket
+import subprocess
 from datetime import datetime
-from typing import Any
+from typing import TYPE_CHECKING, Any
 
 from . import __init__conf__
 from .mail import EmailConfig, send_email
 from .models import PoolIssue, PoolStatus, Severity
 
+if TYPE_CHECKING:
+    from .zfs_client import ZFSClient
+
 logger = logging.getLogger(__name__)
 
 # Binary unit multipliers (powers of 1024)
@@ -75,6 +79,7 @@ class EmailAlerter:
         capacity_warning_percent: int = 80,
         capacity_critical_percent: int = 90,
         scrub_max_age_days: int = 30,
+        zfs_client: ZFSClient | None = None,
     ):
         self.email_config = email_config
         self.subject_prefix = alert_config.get("subject_prefix", "[ZFS Alert]")
@@ -84,6 +89,7 @@ class EmailAlerter:
         self.capacity_warning_percent = capacity_warning_percent
         self.capacity_critical_percent = capacity_critical_percent
         self.scrub_max_age_days = scrub_max_age_days
+        self.zfs_client = zfs_client
 
     def send_alert(self, issue: PoolIssue, pool: PoolStatus) -> bool:
         """Send email alert for a specific pool issue.
@@ -229,7 +235,8 @@ class EmailAlerter:
         str
             Formatted subject line.
         """
-        return f"{self.subject_prefix} {severity.value.upper()} - {pool_name}: {message}"
+        hostname = socket.gethostname()
+        return f"{self.subject_prefix} [{hostname}] {severity.value.upper()} - {pool_name}: {message}"
 
     def _format_recovery_subject(self, pool_name: str, category: str) -> str:
         """Format recovery email subject line.
@@ -246,7 +253,8 @@ class EmailAlerter:
         str
             Formatted subject line.
         """
-        return f"{self.subject_prefix} RECOVERY - {pool_name}: {category} issue resolved"
+        hostname = socket.gethostname()
+        return f"{self.subject_prefix} [{hostname}] RECOVERY - {pool_name}: {category} issue resolved"
 
     def _format_body(self, issue: PoolIssue, pool: PoolStatus) -> str:
         """Format plain-text email body with issue details and pool stats.
@@ -286,6 +294,9 @@ class EmailAlerter:
         )
         lines.append(self._format_complete_pool_status(pool))
 
+        # Add zpool status output if ZFS client is available
+        self._append_zpool_status(lines, pool.name, "email")
+
         return "\n".join(lines)
 
     def _format_alert_header(self, issue: PoolIssue, pool: PoolStatus, hostname: str, timestamp: str) -> list[str]:
@@ -674,6 +685,54 @@ class EmailAlerter:
             return None
         return (datetime.now() - pool.last_scrub.replace(tzinfo=None)).days
 
+    def _append_zpool_status(
+        self,
+        lines: list[str],
+        pool_name: str,
+        email_type: str = "email",
+    ) -> None:
+        """Append zpool status output to email lines.
+
+        Why
+            Eliminates code duplication between alert and recovery email formatting.
+            Centralizes zpool status fetching and error handling in one place.
+
+        Parameters
+        ----------
+        lines:
+            List to append status output to (modified in place).
+        pool_name:
+            Name of the pool to get status for.
+        email_type:
+            Type of email for logging ("email" or "recovery email").
+        """
+        if self.zfs_client is None:
+            return
+
+        try:
+            from .zfs_client import ZFSCommandError
+
+            zpool_status_output = self.zfs_client.get_pool_status_text(pool_name=pool_name)
+            lines.extend(
+                [
+                    "",
+                    "=" * 70,
+                    "ZPOOL STATUS OUTPUT",
+                    "=" * 70,
+                    zpool_status_output.rstrip(),
+                ]
+            )
+        except (ZFSCommandError, subprocess.TimeoutExpired, RuntimeError) as exc:
+            logger.warning(
+                f"Failed to fetch zpool status output for {email_type}",
+                extra={
+                    "pool": pool_name,
+                    "error": str(exc),
+                    "error_type": type(exc).__name__,
+                },
+            )
+            # Continue without zpool status - don't fail the entire email
+
     def _format_recovery_body(self, pool_name: str, category: str, pool: PoolStatus | None = None) -> str:
         """Format recovery email body.
 
@@ -723,4 +782,7 @@ class EmailAlerter:
             )
             lines.append(self._format_complete_pool_status(pool))
 
+            # Add zpool status output if ZFS client is available
+            self._append_zpool_status(lines, pool.name, "recovery email")
+
         return "\n".join(lines)
diff --git a/src/check_zpools/behaviors.py b/src/check_zpools/behaviors.py
index a2c959a..74c950d 100755
--- a/src/check_zpools/behaviors.py
+++ b/src/check_zpools/behaviors.py
@@ -318,6 +318,7 @@ def run_daemon(config: dict[str, Any] | None = None, foreground: bool = False) -
         capacity_warning_percent=monitor_config.capacity_warning_percent,
         capacity_critical_percent=monitor_config.capacity_critical_percent,
         scrub_max_age_days=monitor_config.scrub_max_age_days,
+        zfs_client=client,
     )
 
     # Initialize state management
diff --git a/src/check_zpools/zfs_client.py b/src/check_zpools/zfs_client.py
index ffdd883..0b58295 100755
--- a/src/check_zpools/zfs_client.py
+++ b/src/check_zpools/zfs_client.py
@@ -254,13 +254,62 @@ class ZFSClient:
         logger.debug(f"Executing: {' '.join(command)}")
         return self._execute_json_command(command, timeout=timeout)
 
-    def _execute_json_command(
+    def get_pool_status_text(
+        self,
+        *,
+        pool_name: str | None = None,
+        timeout: int | None = None,
+    ) -> str:
+        """Execute `zpool status` and return plain text output.
+
+        Why
+            Gets human-readable pool status for inclusion in emails and reports.
+            This is the same output administrators see when running zpool status
+            manually.
+
+        Parameters
+        ----------
+        pool_name:
+            Optional specific pool to query. If None, gets all pools.
+        timeout:
+            Command timeout in seconds. Uses default_timeout if None.
+
+        Returns
+        -------
+        str:
+            Plain text output from zpool status command.
+
+        Raises
+        ------
+        ZFSCommandError:
+            When command fails or returns non-zero exit code.
+
+        Examples
+        --------
+        >>> client = ZFSClient()  # doctest: +SKIP
+        >>> text = client.get_pool_status_text(pool_name="rpool")  # doctest: +SKIP
+        >>> "pool: rpool" in text  # doctest: +SKIP
+        True
+        """
+        command = [str(self.zpool_path), "status"]
+
+        if pool_name:
+            command.append(pool_name)
+
+        logger.debug(f"Executing: {' '.join(command)}")
+        return self._execute_text_command(command, timeout=timeout)
+
+    def _execute_command(
         self,
         command: list[str],
         *,
         timeout: int | None = None,
-    ) -> dict[str, Any]:
-        """Execute command and parse JSON output.
+    ) -> subprocess.CompletedProcess[str]:
+        """Execute command and return result.
+
+        Why
+            Common implementation for both JSON and text commands, eliminating
+            code duplication for subprocess execution, logging, and error handling.
 
         Parameters
         ----------
@@ -271,15 +320,13 @@ class ZFSClient:
 
         Returns
         -------
-        dict:
-            Parsed JSON from command stdout.
+        subprocess.CompletedProcess:
+            Completed process with stdout, stderr, and return code.
 
         Raises
         ------
         ZFSCommandError:
-            When command fails.
-        json.JSONDecodeError:
-            When output is not valid JSON.
+            When command fails (non-zero exit code).
         subprocess.TimeoutExpired:
             When command exceeds timeout.
         """
@@ -317,21 +364,7 @@ class ZFSClient:
                 )
                 raise ZFSCommandError(command, result.returncode, result.stderr)
 
-            # Parse JSON output
-            try:
-                data = json.loads(result.stdout)
-                logger.debug(f"Parsed JSON successfully, top-level keys: {list(data.keys())}")
-                return data
-            except json.JSONDecodeError as exc:
-                logger.error(
-                    "Failed to parse JSON output",
-                    extra={
-                        "command": " ".join(command),
-                        "stdout_preview": result.stdout[:500],
-                        "error": str(exc),
-                    },
-                )
-                raise
+            return result
 
         except subprocess.TimeoutExpired:
             logger.error(
@@ -343,6 +376,83 @@ class ZFSClient:
             )
             raise
 
+    def _execute_json_command(
+        self,
+        command: list[str],
+        *,
+        timeout: int | None = None,
+    ) -> dict[str, Any]:
+        """Execute command and parse JSON output.
+
+        Parameters
+        ----------
+        command:
+            Full command to execute as list of strings.
+        timeout:
+            Timeout in seconds. Uses default_timeout if None.
+
+        Returns
+        -------
+        dict:
+            Parsed JSON from command stdout.
+
+        Raises
+        ------
+        ZFSCommandError:
+            When command fails.
+        json.JSONDecodeError:
+            When output is not valid JSON.
+        subprocess.TimeoutExpired:
+            When command exceeds timeout.
+        """
+        result = self._execute_command(command, timeout=timeout)
+
+        # Parse JSON output
+        try:
+            data = json.loads(result.stdout)
+            logger.debug(f"Parsed JSON successfully, top-level keys: {list(data.keys())}")
+            return data
+        except json.JSONDecodeError as exc:
+            logger.error(
+                "Failed to parse JSON output",
+                extra={
+                    "command": " ".join(command),
+                    "stdout_preview": result.stdout[:500],
+                    "error": str(exc),
+                },
+            )
+            raise
+
+    def _execute_text_command(
+        self,
+        command: list[str],
+        *,
+        timeout: int | None = None,
+    ) -> str:
+        """Execute command and return text output.
+
+        Parameters
+        ----------
+        command:
+            Full command to execute as list of strings.
+        timeout:
+            Timeout in seconds. Uses default_timeout if None.
+
+        Returns
+        -------
+        str:
+            Text output from command stdout.
+
+        Raises
+        ------
+        ZFSCommandError:
+            When command fails.
+        subprocess.TimeoutExpired:
+            When command exceeds timeout.
+        """
+        result = self._execute_command(command, timeout=timeout)
+        return result.stdout
+
 
 __all__ = [
     "ZFSClient",
diff --git a/tests/test_alerting.py b/tests/test_alerting.py
index 751e719..1d3fdff 100755
--- a/tests/test_alerting.py
+++ b/tests/test_alerting.py
@@ -203,14 +203,23 @@ class TestEmailSubjectFormatting:
     """When formatting email subjects, content is descriptive and clear."""
 
     def test_format_subject_includes_severity_and_pool(self, alerter: EmailAlerter) -> None:
-        """Subject should include severity, pool name, and message."""
+        """Subject should include hostname, severity, pool name, and message."""
+        import socket
+
         subject = alerter._format_subject(Severity.WARNING, "rpool", "High capacity")
+        hostname = socket.gethostname()
+
+        # Verify exact format: [Prefix] [hostname] SEVERITY - pool: message
+        assert subject.startswith(f"[ZFS Test] [{hostname}]"), f"Subject should start with '[ZFS Test] [{hostname}]', got: {subject}"
 
-        assert "[ZFS Test]" in subject
         assert "WARNING" in subject
         assert "rpool" in subject
         assert "High capacity" in subject
 
+        # Verify bracket structure
+        assert subject.count("[") >= 2, "Subject should have at least 2 opening brackets"
+        assert subject.count("]") >= 2, "Subject should have at least 2 closing brackets"
+
     def test_format_subject_for_critical_issue(self, alerter: EmailAlerter) -> None:
         """Critical issues should be marked in subject."""
         subject = alerter._format_subject(Severity.CRITICAL, "data", "Pool degraded")
@@ -342,14 +351,23 @@ class TestEmailSubjectFormatting:
         assert result is False
 
     def test_format_recovery_subject(self, alerter: EmailAlerter) -> None:
-        """Recovery subject should indicate issue resolved."""
+        """Recovery subject should include hostname and indicate issue resolved."""
+        import socket
+
         subject = alerter._format_recovery_subject("rpool", "capacity")
+        hostname = socket.gethostname()
+
+        # Verify exact format: [Prefix] [hostname] RECOVERY - pool: message
+        assert subject.startswith(f"[ZFS Test] [{hostname}]"), f"Subject should start with '[ZFS Test] [{hostname}]', got: {subject}"
 
-        assert "[ZFS Test]" in subject
         assert "RECOVERY" in subject
         assert "rpool" in subject
         assert "capacity" in subject
 
+        # Verify bracket structure
+        assert subject.count("[") >= 2, "Subject should have at least 2 opening brackets"
+        assert subject.count("]") >= 2, "Subject should have at least 2 closing brackets"
+
     def test_format_recovery_body(self, alerter: EmailAlerter) -> None:
         """Recovery body should indicate issue resolved."""
         body = alerter._format_recovery_body("rpool", "capacity")
